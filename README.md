# krisyuk_itp_devops_pr
Крисюк Вадим (Практика АйтиПелаг DevOps)

# Задание Nginx
Для начала были созданы и запущены три Docker-контейнра с проектами на разных портах: Java Spring, Python FastAPI, PHP Laravel. Java Spring запускался на порту 8001, PHP Laravel на порту 8002, Python FastAPI – 8003.  
![n1](/images/n1.png)<br>
Рисунок 1 – Запуск контейнеров 

![n2](/images/n2.png)<br>
Рисунок 2 – Проверка запуска приложений

Далее был установлен Nginx со всеми обновлениями. В папке конфигурационных файлов был создан файл, в который вписан код для управления серверами. Сначала введем для всех портов одинаковый вес (weight = 1)  
![n3](/images/n3.png)<br>
Рисунок 3 – Код конфигурационного файла

При запуске серверов соотношение запусков приложений оказалось 3:3:4 
![n4](/images/n4.png)<br>
Рисунок 4 – Запуск серверов

Теперь изменим вес каждого порта и посмотрим, как поменяется соотношение запусков приложений. Для этого поменяем вес у портов в соотношение 1:2:4 и поставим в цикле 70 запусков, чтобы было наглядно видно что получится:
```
upstream backend {
    least_conn;  
    server localhost:8001 weight=1;  #java
    server localhost:8002 weight=2;  #php
    server localhost:8003 weight=4;  #python
}
```

В итоге количество запусков совпало с соотношением 1:2:4
![n5](/images/n5.png)<br>
Рисунок 5 – Количество запусков

**Вывод:** Была разработана программа, которая делала N запросов к адресу http://localhost определяла ЯП, на котором написан сервис (ЯП присутствует в ответе сервиса).

---

# Задание Мониторинг (Prometheus+Grafana)
В качестве основы было взято небольшое приложение на языке Pyhton
Для мониторинга и алертинга был выбран стек Prometheus+Grafana+Loki+Promtail. Были созданы файлы docker-compose.yml, loki-config.yml, prometheus.yml. С помощью команды docker compose up был запущен проект.
<br>![m1](/images/m1.png)<br>
Рисунок 1 – Данные на странице http://localhost:8080/

![m2](/images/m2.png)<br>
Рисунок 2 – Данные на странице http://localhost:9090/targets

![m3](/images/m3.png)<br>
Рисунок 3 – Данные на странице http://localhost:3000

Затем в Grafana были подключены источники данных, с которых необходимо будет считывать логи и метрики.
![m4](/images/m4.png)<br>
Рисунок 4 – Источники данных для сбора логов и метрик

Далее был настроен дашборд, в котором можно видеть логи, количество запросов и нагрузку CPU.
![m5](/images/m5.png)<br>
Рисунок 5 – Дашборд Grafana

Также был создан алерт, если нагрузка CPU становится выше 80%.
![m6](/images/m6.png)<br>
Рисунок 6 – Настройка алерта CPU

Через Apache Benchmark была создана нагрузка, которая отобразилась на дашборде Grafana
![m7](/images/m7.png)<br>
Рисунок 7 – Отображение нагрузки на дашборде.

Также удалось нагрузить систему выше 80%, после чего видно, что на почту пошло уведомление.
![m8](/images/m8.png)<br>
Рисунок 8 – Нагрузка свыше 80%

![m9](/images/m9.png)<br>
Рисунок 9 – Отправка уведомления на почту

**Вывод:** В ходе выполнения задания был успешно развёрнут стек мониторинга на основе Prometheus, Grafana, Loki и Promtail для отслеживания метрик, логов и алертинга Python-приложения.

---

## Контакты
[Telegram](https://t.me/sadlyaguha)
